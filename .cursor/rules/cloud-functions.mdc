<!-- Quality Standards Enforced: E (Reliability), F (Performance) -->
<!-- Template Base: Google Cloud Functions (Original) -->
<!-- Last Updated: 2026-02-12 -->

# Google Cloud Functions Rules

## Standards Enforced

- **E. Reliability**: Error handling, retry logic, timeouts, graceful degradation
- **F. Performance**: Cold start optimization, memory awareness, caching

<!-- ORIGINAL: GCP Official Documentation -->

## Cloud Functions Gen2 Overview

cwayassistant uses **Google Cloud Functions gen2** (built on Cloud Run):
- HTTP function: `app` (handles Chat API interactions)
- Events function: `eventsApp` (handles Workspace Events via Pub/Sub)

## HTTP Functions

### Function Signature
```javascript
// Entry point (exported)
exports.app = (req, res) => {
  // Handle request
  res.status(200).send('Response');
};

// Or with Express app
const express = require('express');
const app = express();

app.post('/endpoint', (req, res) => {
  res.json({ result: 'data' });
});

exports.app = app;
```

### Request Handling
- Access request body: `req.body` (JSON parsed automatically)
- Access query parameters: `req.query`
- Access URL parameters: `req.params`
- Access headers: `req.headers`

```javascript
exports.app = (req, res) => {
  const { message } = req.body;
  const userId = req.query.userId;
  const token = req.headers.authorization;
  
  // Process request
  res.status(200).json({ success: true });
};
```

### Response Handling
- Use appropriate status codes: 200, 201, 400, 401, 404, 500
- Set response headers if needed
- Return JSON with `res.json(data)` or text with `res.send(text)`
- Always send response (don't leave hanging)

```javascript
exports.app = async (req, res) => {
  try {
    // Validate input
    if (!req.body.data) {
      return res.status(400).json({ error: 'Missing required field: data' });
    }
    
    // Process
    const result = await processData(req.body.data);
    
    // Success response
    return res.status(200).json({ result });
  } catch (error) {
    console.error({ error, requestBody: req.body });
    return res.status(500).json({ error: 'Internal server error' });
  }
};
```

### CORS Handling
For client-facing endpoints, configure CORS:

```javascript
exports.app = (req, res) => {
  // Set CORS headers
  res.set('Access-Control-Allow-Origin', '*'); // Or specific origin
  res.set('Access-Control-Allow-Methods', 'GET, POST');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  
  // Handle preflight OPTIONS request
  if (req.method === 'OPTIONS') {
    return res.status(204).send('');
  }
  
  // Handle actual request
  res.json({ data: 'value' });
};
```

## Events Functions

### CloudEvents Format
Workspace Events and Pub/Sub use CloudEvents format:

```javascript
exports.eventsApp = (event) => {
  // event.type: Event type (e.g., "google.workspace.chat.message.v1.created")
  // event.data: Actual event payload
  // event.id: Unique event ID
  // event.source: Event source
  
  const eventType = event.type;
  const eventData = event.data;
  
  console.log({ eventType, eventId: event.id, eventData });
  
  // Route to appropriate handler
  if (eventType.includes('message.created')) {
    return handleMessageCreated(eventData);
  }
  // ...
};
```

### Extracting Event Data
```javascript
exports.eventsApp = async (event) => {
  try {
    // Validate event structure
    if (!event || !event.data) {
      console.error('Invalid event structure', { event });
      return; // Events functions don't return values
    }
    
    // Extract data
    const { message, space, user } = event.data;
    
    // Process event
    await processMessage(message, space, user);
    
    // Log success
    console.log({ eventId: event.id, status: 'processed' });
  } catch (error) {
    // Log error (don't throw - would trigger retry)
    console.error({ error, eventId: event.id });
  }
};
```

### Idempotency
Events may be delivered multiple times. Implement idempotency:

```javascript
exports.eventsApp = async (event) => {
  const eventId = event.id;
  
  // Check if already processed
  const processed = await checkIfProcessed(eventId);
  if (processed) {
    console.log({ eventId, status: 'duplicate, skipped' });
    return;
  }
  
  // Process event
  await processEvent(event.data);
  
  // Mark as processed
  await markAsProcessed(eventId);
};

// Implementation example
const processedEvents = new Set(); // In-memory (simple)
// Or use Firestore/Redis for persistent deduplication

async function checkIfProcessed(eventId) {
  return processedEvents.has(eventId);
  // Or: const doc = await firestore.collection('processed_events').doc(eventId).get();
  // return doc.exists;
}

async function markAsProcessed(eventId) {
  processedEvents.add(eventId);
  // Or: await firestore.collection('processed_events').doc(eventId).set({ timestamp: new Date() });
}
```

## Cold Start Optimization

### Problem
Cloud Functions have "cold starts" when instance is created:
- New container initialization: ~1-3 seconds
- Loading dependencies: depends on bundle size
- Target: <3 seconds total cold start

### Solution: Global Variable Reuse
Initialize expensive resources **outside** the function handler (at module level):

```javascript
// ❌ BAD: Initialize inside handler (every invocation)
exports.app = async (req, res) => {
  const firestore = new Firestore(); // Created on EVERY request!
  const data = await firestore.collection('data').get();
  res.json({ data });
};

// ✅ GOOD: Initialize at module level (once per cold start)
const { Firestore } = require('@google-cloud/firestore');
const firestore = new Firestore(); // Created once, reused

exports.app = async (req, res) => {
  const data = await firestore.collection('data').get(); // Reuses connection
  res.json({ data });
};
```

### What to Initialize Globally
- Database clients (Firestore, SQL)
- API clients (Chat, Vertex AI, Events)
- HTTP connection pools
- Configuration objects
- Heavy computation results

```javascript
// Global initialization (module level)
const { Firestore } = require('@google-cloud/firestore');
const { VertexAI } = require('@google-cloud/vertexai');
const { google } = require('googleapis');

const firestore = new Firestore();
const vertexAI = new VertexAI({ project: process.env.PROJECT_ID, location: 'us-central1' });
const chat = google.chat('v1');

// Function handler (reuses globals)
exports.app = async (req, res) => {
  const messages = await firestore.collection('messages').get();
  const aiResponse = await vertexAI.predict({ prompt: req.body.text });
  res.json({ messages, aiResponse });
};
```

### What NOT to Initialize Globally
- Request-specific state (different per request)
- Mutable state (risk of cross-request contamination)
- Short-lived data

```javascript
// ❌ BAD: Request-specific state as global
let currentUser; // Shared across requests!

exports.app = (req, res) => {
  currentUser = getUserFromToken(req.headers.authorization); // Overwrites for concurrent requests!
  // ...
};

// ✅ GOOD: Request-specific state as local
exports.app = (req, res) => {
  const currentUser = getUserFromToken(req.headers.authorization); // Scoped to request
  // ...
};
```

### Bundle Size Optimization
- Keep dependencies minimal
- Use dynamic imports for optional features:
  ```javascript
  if (needsFeature) {
    const { feature } = await import('./optional-feature');
    feature();
  }
  ```
- Avoid large libraries unless necessary
- Tree-shake unused code (use bundlers if needed)

## Error Handling

### Structured Logging for Cloud Logging
Use JSON logging for better querying in Cloud Logging:

```javascript
exports.app = async (req, res) => {
  try {
    const result = await processRequest(req.body);
    
    // Structured info log
    console.log({
      severity: 'INFO',
      message: 'Request processed successfully',
      requestId: req.headers['x-request-id'],
      userId: req.body.userId,
      duration: Date.now() - startTime
    });
    
    res.json({ result });
  } catch (error) {
    // Structured error log
    console.error({
      severity: 'ERROR',
      message: 'Request processing failed',
      error: error.message,
      stack: error.stack,
      requestId: req.headers['x-request-id'],
      requestBody: req.body
    });
    
    res.status(500).json({ error: 'Internal server error' });
  }
};
```

### Error Severity Levels
- **ERROR**: Errors requiring attention
- **WARNING**: Potential issues
- **INFO**: General information
- **DEBUG**: Detailed debugging info

### Don't Expose Internal Errors
```javascript
// ❌ BAD: Exposes internal details
catch (error) {
  res.status(500).json({ error: error.message }); // May leak sensitive info!
}

// ✅ GOOD: Generic error message
catch (error) {
  console.error({ error, context: 'processingRequest' });
  res.status(500).json({ error: 'Internal server error' });
}

// ✅ GOOD: Differentiate client vs server errors
catch (error) {
  if (error instanceof ValidationError) {
    return res.status(400).json({ error: error.message }); // Safe to expose
  }
  console.error({ error, context: 'processingRequest' });
  res.status(500).json({ error: 'Internal server error' });
}
```

### Graceful Degradation
Handle external service failures gracefully:

```javascript
exports.app = async (req, res) => {
  try {
    // Primary service
    const data = await primaryService.getData();
    res.json({ data, source: 'primary' });
  } catch (error) {
    console.warn({ error, message: 'Primary service failed, using fallback' });
    
    try {
      // Fallback service
      const data = await fallbackService.getData();
      res.json({ data, source: 'fallback' });
    } catch (fallbackError) {
      console.error({ fallbackError, message: 'Both services failed' });
      res.status(503).json({ error: 'Service temporarily unavailable' });
    }
  }
};
```

## Timeouts and Retry Logic

### Configure Timeouts
```bash
# Deployment
gcloud functions deploy app \
  --gen2 \
  --timeout=60s  # Default 60s, max 540s (9 minutes)
```

In code, handle long operations with timeouts:
```javascript
const timeout = (ms) => new Promise((_, reject) =>
  setTimeout(() => reject(new Error('Operation timed out')), ms)
);

exports.app = async (req, res) => {
  try {
    const result = await Promise.race([
      processRequest(req.body),
      timeout(30000) // 30-second timeout
    ]);
    res.json({ result });
  } catch (error) {
    if (error.message === 'Operation timed out') {
      return res.status(504).json({ error: 'Request timeout' });
    }
    // Handle other errors
  }
};
```

### Retry Logic with Exponential Backoff
For transient failures (network, rate limits):

```javascript
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      const isLastAttempt = attempt === maxRetries - 1;
      const isRetryable = error.code === 'UNAVAILABLE' || error.code === 429;
      
      if (isLastAttempt || !isRetryable) {
        throw error;
      }
      
      const delay = baseDelay * Math.pow(2, attempt); // Exponential backoff
      console.warn({ attempt, delay, error: error.message, message: 'Retrying...' });
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
exports.app = async (req, res) => {
  try {
    const result = await retryWithBackoff(() => externalAPI.call(req.body));
    res.json({ result });
  } catch (error) {
    console.error({ error, message: 'All retries failed' });
    res.status(503).json({ error: 'Service unavailable' });
  }
};
```

## Environment Configuration

### Use Environment Variables
```javascript
const config = {
  projectId: process.env.PROJECT_ID,
  region: process.env.REGION || 'us-central1',
  topicName: process.env.TOPIC_NAME,
  enableLogging: process.env.ENABLE_LOGGING === 'true'
};

// Never hardcode
// ❌ const projectId = 'my-project-id';
```

### Set During Deployment
```bash
gcloud functions deploy app \
  --gen2 \
  --set-env-vars PROJECT_ID=my-project,REGION=us-central1,TOPIC_NAME=events-api
```

### Use Secret Manager for Sensitive Values
```javascript
const { SecretManagerServiceClient } = require('@google-cloud/secret-manager');
const client = new SecretManagerServiceClient();

async function getSecret(secretName) {
  const [version] = await client.accessSecretVersion({
    name: `projects/${PROJECT_ID}/secrets/${secretName}/versions/latest`
  });
  return version.payload.data.toString();
}

// Use in function
const apiKey = await getSecret('api-key');
```

## Memory and Performance

### Configure Memory Allocation
```bash
gcloud functions deploy app \
  --gen2 \
  --memory=512MB  # Options: 128MB, 256MB, 512MB, 1GB, 2GB, 4GB, 8GB
```

Higher memory = more CPU allocated. For CPU-intensive tasks, increase memory.

### Monitor Performance
- Use Cloud Monitoring to track:
  - Execution time
  - Memory usage
  - Cold start frequency
  - Error rate

### Optimize Database Queries
- Use Firestore indexes for frequent queries
- Limit query results (pagination)
- Cache frequently accessed data

```javascript
// ❌ BAD: Fetches all documents
const snapshot = await firestore.collection('messages').get();

// ✅ GOOD: Paginated query with index
const snapshot = await firestore
  .collection('messages')
  .where('spaceId', '==', spaceId) // Indexed field
  .orderBy('timestamp', 'desc')
  .limit(50)
  .get();
```

## Deployment Best Practices

### Gen2 Deployment Command Template
```bash
gcloud functions deploy FUNCTION_NAME \
  --gen2 \
  --region=us-central1 \
  --runtime=nodejs22 \
  --source=. \
  --entry-point=ENTRY_POINT \
  --trigger-http \  # Or --trigger-topic for Events
  --allow-unauthenticated \  # Only for public endpoints
  --timeout=60s \
  --memory=512MB \
  --set-env-vars KEY=VALUE,KEY2=VALUE2 \
  --max-instances=10  # Control concurrency
```

### HTTP Function Example
```bash
gcloud functions deploy app \
  --gen2 \
  --region=us-central1 \
  --runtime=nodejs22 \
  --source=. \
  --entry-point=app \
  --trigger-http \
  --allow-unauthenticated \
  --timeout=60s \
  --memory=512MB \
  --set-env-vars PROJECT_ID=my-project,REGION=us-central1
```

### Events Function Example
```bash
gcloud functions deploy events-app \
  --gen2 \
  --region=us-central1 \
  --runtime=nodejs22 \
  --source=. \
  --entry-point=eventsApp \
  --trigger-topic=events-api \
  --timeout=60s \
  --memory=512MB
```

### Use Labels for Organization
```bash
gcloud functions deploy app \
  --gen2 \
  --labels=env=production,version=v1,team=backend
```

## Testing Cloud Functions Locally

### Use Functions Framework
```bash
npm install --save-dev @google-cloud/functions-framework

# Run HTTP function locally
npx functions-framework --target=app --port=8080

# Run Events function locally (use CloudEvents format)
npx functions-framework --target=eventsApp --signature-type=cloudevent
```

### Test with curl
```bash
# HTTP function
curl -X POST http://localhost:8080 \
  -H "Content-Type: application/json" \
  -d '{"message":{"text":"Hello"}}'

# Events function (CloudEvents format)
curl -X POST http://localhost:8080 \
  -H "Content-Type: application/json" \
  -H "ce-id: 123" \
  -H "ce-source: test" \
  -H "ce-type: google.workspace.chat.message.v1.created" \
  -H "ce-specversion: 1.0" \
  -d '{"message":{"text":"Hello"}}'
```
