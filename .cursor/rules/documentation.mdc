<!-- Quality Standards Enforced: D (Documentation) -->
<!-- Template Base: Documentation (Original) -->
<!-- Last Updated: 2026-02-12 -->

# Documentation Rules

## Standards Enforced

- **D. Documentation**: JSDoc 100% public functions, README maintenance, ADR process, inline comments

<!-- ORIGINAL: Documentation Best Practices -->

## JSDoc for Functions

### Requirement
**ALL public functions MUST have JSDoc comments** with:
- Description (what the function does)
- `@param` for each parameter (type + description)
- `@returns` for return value (type + description)
- `@throws` if function can throw errors
- `@example` for complex functions or public APIs

### Basic Template
```javascript
/**
 * Brief description of what the function does
 * @param {Type} paramName - Description of parameter
 * @returns {ReturnType} Description of return value
 * @throws {ErrorType} Description of when error is thrown
 */
function myFunction(paramName) {
  // Implementation
}
```

### Complete Example
```javascript
/**
 * Authenticates user using OAuth2 and returns JWT token
 * @param {Object} req - Express request object
 * @param {string} req.body.code - OAuth2 authorization code
 * @param {string} req.body.redirectUri - OAuth2 redirect URI
 * @returns {Promise<string>} JWT token for authenticated user
 * @throws {Error} If authentication fails or code is invalid
 * @example
 * const token = await authenticateUser(req);
 * // Returns "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
 */
async function authenticateUser(req) {
  const { code, redirectUri } = req.body;
  
  if (!code) {
    throw new Error('Authorization code is required');
  }
  
  const tokens = await oauth2Client.getToken({ code, redirect_uri: redirectUri });
  return generateJWT(tokens);
}
```

### Async Functions
Always specify `Promise<Type>` for return type:

```javascript
/**
 * Fetches user data from Firestore
 * @param {string} userId - Unique user identifier
 * @returns {Promise<Object>} User data object
 * @returns {string} returns.name - User's name
 * @returns {string} returns.email - User's email
 * @throws {Error} If user not found or database error
 */
async function getUserData(userId) {
  const doc = await firestore.collection('users').doc(userId).get();
  
  if (!doc.exists) {
    throw new Error(`User not found: ${userId}`);
  }
  
  return doc.data();
}
```

### Object Parameters
Use nested `@param` for object properties:

```javascript
/**
 * Creates a new message in Firestore
 * @param {Object} message - Message object
 * @param {string} message.text - Message text content
 * @param {Object} message.sender - Message sender information
 * @param {string} message.sender.name - Sender's name
 * @param {string} message.sender.email - Sender's email
 * @param {string} message.spaceId - ID of the space containing the message
 * @param {Date} [message.timestamp] - Message timestamp (optional, defaults to now)
 * @returns {Promise<string>} ID of created message document
 */
async function createMessage(message) {
  const { text, sender, spaceId, timestamp = new Date() } = message;
  
  const doc = await firestore.collection('messages').add({
    text,
    sender,
    spaceId,
    timestamp
  });
  
  return doc.id;
}
```

### Optional Parameters
Use `[paramName]` for optional params:

```javascript
/**
 * Fetches messages from a space with optional filtering
 * @param {string} spaceId - Space identifier
 * @param {number} [limit=50] - Maximum number of messages to return (default: 50)
 * @param {string} [startAfter] - Cursor for pagination (optional)
 * @returns {Promise<Array<Object>>} Array of message objects
 */
async function fetchMessages(spaceId, limit = 50, startAfter = null) {
  let query = firestore.collection('messages')
    .where('spaceId', '==', spaceId)
    .orderBy('timestamp', 'desc')
    .limit(limit);
  
  if (startAfter) {
    query = query.startAfter(startAfter);
  }
  
  const snapshot = await query.get();
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}
```

## JSDoc for Classes

### Class Documentation
```javascript
/**
 * Service for managing user authentication and OAuth2 flows
 * @class
 */
class AuthService {
  /**
   * Creates an instance of AuthService
   * @param {Object} config - Configuration object
   * @param {string} config.clientId - OAuth2 client ID
   * @param {string} config.clientSecret - OAuth2 client secret
   * @param {string} config.redirectUri - OAuth2 redirect URI
   */
  constructor(config) {
    this.config = config;
    this.oauth2Client = createOAuth2Client(config);
  }

  /**
   * Authenticates user and returns access token
   * @param {string} authorizationCode - OAuth2 authorization code
   * @returns {Promise<Object>} Token object
   * @returns {string} returns.accessToken - Access token
   * @returns {string} returns.refreshToken - Refresh token
   * @returns {number} returns.expiresIn - Token expiration time in seconds
   * @throws {Error} If authentication fails
   */
  async authenticate(authorizationCode) {
    const tokens = await this.oauth2Client.getToken(authorizationCode);
    return this.formatTokens(tokens);
  }

  /**
   * Refreshes expired access token
   * @param {string} refreshToken - OAuth2 refresh token
   * @returns {Promise<string>} New access token
   * @throws {Error} If refresh fails
   */
  async refreshAccessToken(refreshToken) {
    this.oauth2Client.setCredentials({ refresh_token: refreshToken });
    const response = await this.oauth2Client.refreshAccessToken();
    return response.credentials.access_token;
  }
}

module.exports = { AuthService };
```

## Type Definitions

### Custom Types with @typedef
Define reusable types:

```javascript
/**
 * @typedef {Object} Message
 * @property {string} id - Unique message identifier
 * @property {string} text - Message text content
 * @property {Sender} sender - Message sender information
 * @property {string} spaceId - ID of the space containing the message
 * @property {Date} timestamp - Message creation timestamp
 */

/**
 * @typedef {Object} Sender
 * @property {string} name - Sender's display name
 * @property {string} email - Sender's email address
 * @property {string} type - Sender type (HUMAN, BOT)
 */

/**
 * Stores a message in Firestore
 * @param {Message} message - Message object to store
 * @returns {Promise<void>}
 */
async function storeMessage(message) {
  await firestore.collection('messages').doc(message.id).set(message);
}
```

## Inline Comments

### When to Add Comments
- **Complex algorithms** or business logic
- **Non-obvious workarounds** or hacks
- **Performance optimizations** with rationale
- **Integration quirks** with external systems
- **Security considerations** and validations
- **TODO items** and technical debt

### What NOT to Comment
- Obvious code (e.g., "increment counter")
- Redundant descriptions of what code does
- Commented-out code (delete it, use git history)
- Personal notes or debugging info

### Comment Style
Write comments that explain **WHY, not WHAT**:

```javascript
// ✅ GOOD: Explains WHY
// Use exponential backoff to avoid overwhelming the Chat API during retries
await retryWithBackoff(() => sendMessage(spaceId, text));

// Workaround for Workspace Events API bug #1234:
// API returns 200 with error in response body instead of proper error status
if (response.status === 200 && response.body.error) {
  throw new Error(response.body.error);
}

// Cache Vertex AI responses for 1 hour to reduce API costs and improve latency
const cachedResponse = await getFromCache(question);

// ❌ BAD: Explains WHAT (obvious from code)
// Call the sendMessage function
await sendMessage(spaceId, text);

// Increment the counter variable
counter++;

// Check if user is authenticated
if (isAuthenticated) { ... }
```

### TODO, FIXME, HACK Comments
```javascript
// TODO: Refactor this to use async/await instead of callbacks (low priority)
// FIXME: Memory leak when processing large files - issue #456 (high priority)
// HACK: API doesn't support pagination, loading all results at once (performance issue)
// WORKAROUND: Google Chat API has 5-second timeout, splitting large responses
```

## README.md Maintenance

### Required Sections
1. **Project Title and Description**
2. **Architecture Overview** with diagrams
3. **Quick Start / Getting Started**
4. **Environment Variables and Configuration**
5. **Usage Instructions** (run, test, lint, deploy)
6. **API Documentation** (if applicable)
7. **Testing**
8. **Contributing Guidelines**
9. **License and Credits**
10. **Rules Provenance** (link to `.cursor/imports/PROVENANCE.md`)

### Living Documentation Rule
**CRITICAL:** Update README.md whenever:
- File/folder structure changes (add/remove directories or files)
- Logical flow changes (new integration, removed feature, architecture shift)
- Environment variables change
- Deployment process changes

**What to update:**
- Repository tree diagram with inline descriptions
- Mermaid flowchart to reflect new flow
- Environment variable documentation
- Installation/deployment instructions

### Repository Tree Diagram
Include tree with inline descriptions:

```markdown
## Repository Structure

```
cwayassistant/                        # Root directory
├── controllers/                      # HTTP/Events handlers
│   ├── app.js                        # Main HTTP function (Chat interactions)
│   └── event-app.js                  # Events function (Pub/Sub messages)
├── services/                         # Business logic layer
│   ├── aip-service.js                # Vertex AI / Gemini integration
│   ├── firestore-service.js          # Firestore data access
│   └── ...                           # Auth services (user/app, chat/events)
├── model/                            # Data models and domain logic
│   ├── message.js                    # Message entity
│   ├── events.js                     # Event types and handlers
│   └── exceptions.js                 # Custom error classes
├── test/                             # Unit tests (Mocha + Supertest)
├── .cursor/                          # Cursor AI configuration
│   ├── rules/                        # Domain rules (.mdc)
│   └── imports/                      # Template provenance
├── index.js                          # Main entry point
└── package.json                      # Dependencies and scripts
```

**Brief descriptions per folder:**
- **controllers**: Handle HTTP/Pub/Sub requests, delegate to services
- **services**: Business logic, API integrations (Chat, Firestore, Vertex AI)
- **model**: Domain entities and core logic
- **test**: Unit tests with Mocha and Supertest
```

### Mermaid Flowchart
Include logical flow diagram with explanation:

```markdown
## Architecture Flow

```mermaid
flowchart TD
    User[Google Chat User] -->|sends message| ChatAPI[Google Chat API]
    ChatAPI -->|HTTP request| HTTPFunc[HTTP Function app]
    HTTPFunc -->|authenticate user| OAuth2[OAuth2 Flow]
    OAuth2 -->|store token| Firestore[(Firestore)]
    HTTPFunc -->|create subscription| EventsAPI[Workspace Events API]
    EventsAPI -->|publish event| PubSub[Pub/Sub Topic]
    PubSub -->|trigger| EventsFunc[Events Function eventsApp]
    EventsFunc -->|store message| Firestore
    EventsFunc -->|detect question| VertexAI[Vertex AI Gemini]
    VertexAI -->|retrieve context| Firestore
    VertexAI -->|generate answer| Response[Chat Response]
    Response -->|send via Chat API| ChatAPI
    ChatAPI -->|deliver| User
```

**Flow explanation:**
1. User sends message → Google Chat API receives it
2. HTTP Function handles user interaction and OAuth2 authentication
3. Subscription created via Workspace Events API for real-time monitoring
4. Events published to Pub/Sub topic when messages are created/updated
5. Events Function stores messages in Firestore
6. Vertex AI Gemini detects questions and retrieves conversation history
7. Generated answer sent back to Chat via Chat API
```

## Architecture Decision Records (ADRs)

### When to Create ADRs
- Significant architectural changes
- Technology stack decisions (e.g., choosing Firestore over MongoDB)
- Design pattern adoptions (e.g., using controllers/services/model)
- Performance vs maintainability trade-offs
- Security design decisions
- Breaking changes to APIs

### ADR Structure
Create in `/docs/adr/` with sequential numbering: `0001-decision-name.md`, `0002-next-decision.md`

**Template:**
```markdown
# ADR XXXX: Decision Title

## Status
[Proposed | Accepted | Deprecated | Superseded by ADR-YYYY]

## Context
Describe the problem, constraints, and requirements that led to this decision.
- What forces are at play? (technical, political, social, project local)
- What are the goals?
- What are the constraints?

## Decision
What was decided and why.
- Describe the solution
- Explain the reasoning
- List alternatives considered and why they were rejected

## Consequences
What becomes easier or more difficult because of this change.

**Positive:**
- List positive outcomes
- Benefits gained

**Negative:**
- List negative outcomes
- Trade-offs accepted

**Mitigation:**
- How negative consequences are addressed
```

### Example ADR
```markdown
# ADR 0002: Use Vertex AI Gemini for Question Answering

## Status
Accepted (2026-01-15)

## Context
The cwayassistant needs to detect questions in chat messages and generate intelligent answers based on conversation history.

Requirements:
- Real-time question detection
- Context-aware answer generation
- Integration with Google Workspace (same cloud provider)
- Cost-effective for expected usage (100-500 requests/day)

Alternatives considered:
1. OpenAI GPT-4 API
2. Anthropic Claude API
3. Self-hosted open-source model (Llama 2)
4. Vertex AI Gemini

## Decision
Use **Vertex AI Gemini 1.5 Flash** for question detection and answer generation.

Reasoning:
- Native Google Cloud integration (same project, IAM, billing)
- Gemini 1.5 Flash optimized for low latency and cost
- No need to manage API keys (uses service account)
- Excellent context window (1M tokens)
- Competitive pricing for our usage volume

## Consequences

**Positive:**
- Simplified authentication (service account, no API keys)
- Low latency (same region as Cloud Functions)
- Good cost efficiency (Flash model is cheaper than Pro)
- Easy monitoring via Cloud Console

**Negative:**
- Vendor lock-in to Google Cloud
- Limited model customization compared to fine-tuning
- Gemini API may have breaking changes

**Mitigation:**
- Abstract AI calls behind service interface for easy model swapping
- Monitor API costs and set budget alerts
- Stay updated with Gemini API changelog
```

## Living Documentation in Task Summaries

After every task that modifies files, mention in summary:

```
Task: Add retry logic to Chat API calls

Changes:
- Modified: services/chat-service.js (added exponential backoff)
- Modified: README.md (updated architecture flow to include retry logic)
- Modified: /.cursor/rules/google-apis.mdc (documented retry pattern)
- Tests: npm test passed; coverage 76% → 78%

Quality Gates: ✅ lint ✅ format:check ✅ typecheck ✅ test
```

## Documentation Best Practices

1. **Write JSDoc as you code** - Don't leave it for later
2. **Update comments when code changes** - Outdated comments are worse than no comments
3. **Keep README in sync** - Update immediately after structural changes
4. **Use meaningful examples** - Show realistic use cases in @example tags
5. **Link related docs** - Use markdown links to connect ADRs, README sections
6. **Document assumptions** - Especially for workarounds and hacks
7. **Be concise** - Clear, short descriptions are better than long explanations
8. **Avoid jargon** - Use plain language when possible
9. **Use active voice** - "Authenticates user" not "User is authenticated"
10. **Proofread** - Check for typos, grammar, clarity before committing
